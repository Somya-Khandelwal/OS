From 7dbea85cb24d24bbc3a1a87fd5bdafe642ffbdfe Mon Sep 17 00:00:00 2001
From: Pranav <pranav.ag800@gmail.com>
Date: Mon, 5 Sep 2022 22:43:45 +0530
Subject: [PATCH] Assignment done

---
 .vscode/settings.json  |  17 +
 Makefile               |   6 +-
 defs.h                 | 267 ++++++------
 mutex.c                |  24 +
 mutex.h                |   6 +
 proc.c                 | 964 ++++++++++++++++++++++++-----------------
 syscall.c              | 160 ++++---
 syscall.h              |  45 +-
 sysproc.c              | 160 ++++---
 thread_test.c          |  57 +++
 thread_test_mutex.c    |  70 +++
 thread_test_spinlock.c |  72 +++
 user.h                 |  57 ++-
 usys.S                 |  13 +
 14 files changed, 1226 insertions(+), 692 deletions(-)
 create mode 100644 .vscode/settings.json
 create mode 100644 mutex.c
 create mode 100644 mutex.h
 create mode 100644 thread_test.c
 create mode 100644 thread_test_mutex.c
 create mode 100644 thread_test_spinlock.c

diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..ebdd105
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,17 @@
+{
+    "files.associations": {
+        "*.ejs": "html",
+        "stat.h": "c",
+        "param.h": "c",
+        "mmu.h": "c",
+        "proc.h": "c",
+        "defs.h": "c",
+        "user.h": "c",
+        "spinlock.h": "c",
+        "types.h": "c",
+        "date.h": "c",
+        "x86.h": "c",
+        "memlayout.h": "c",
+        "mutex.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 09d790c..0886ba5 100644
--- a/Makefile
+++ b/Makefile
@@ -178,9 +178,11 @@ UPROGS=\
 	_rm\
 	_sh\
 	_stressfs\
-	_usertests\
 	_wc\
 	_zombie\
+	_thread_test\
+	_thread_test_spinlock\
+	_thread_test_mutex\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -249,7 +251,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c wc.c zombie.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
diff --git a/defs.h b/defs.h
index 82fb982..6b86dfb 100644
--- a/defs.h
+++ b/defs.h
@@ -6,185 +6,192 @@ struct pipe;
 struct proc;
 struct rtcdate;
 struct spinlock;
+struct mutexlock;
 struct sleeplock;
 struct stat;
 struct superblock;
 
 // bio.c
-void            binit(void);
-struct buf*     bread(uint, uint);
-void            brelse(struct buf*);
-void            bwrite(struct buf*);
+void binit(void);
+struct buf *bread(uint, uint);
+void brelse(struct buf *);
+void bwrite(struct buf *);
 
 // console.c
-void            consoleinit(void);
-void            cprintf(char*, ...);
-void            consoleintr(int(*)(void));
-void            panic(char*) __attribute__((noreturn));
+void consoleinit(void);
+void cprintf(char *, ...);
+void consoleintr(int (*)(void));
+void panic(char *) __attribute__((noreturn));
 
 // exec.c
-int             exec(char*, char**);
+int exec(char *, char **);
 
 // file.c
-struct file*    filealloc(void);
-void            fileclose(struct file*);
-struct file*    filedup(struct file*);
-void            fileinit(void);
-int             fileread(struct file*, char*, int n);
-int             filestat(struct file*, struct stat*);
-int             filewrite(struct file*, char*, int n);
+struct file *filealloc(void);
+void fileclose(struct file *);
+struct file *filedup(struct file *);
+void fileinit(void);
+int fileread(struct file *, char *, int n);
+int filestat(struct file *, struct stat *);
+int filewrite(struct file *, char *, int n);
 
 // fs.c
-void            readsb(int dev, struct superblock *sb);
-int             dirlink(struct inode*, char*, uint);
-struct inode*   dirlookup(struct inode*, char*, uint*);
-struct inode*   ialloc(uint, short);
-struct inode*   idup(struct inode*);
-void            iinit(int dev);
-void            ilock(struct inode*);
-void            iput(struct inode*);
-void            iunlock(struct inode*);
-void            iunlockput(struct inode*);
-void            iupdate(struct inode*);
-int             namecmp(const char*, const char*);
-struct inode*   namei(char*);
-struct inode*   nameiparent(char*, char*);
-int             readi(struct inode*, char*, uint, uint);
-void            stati(struct inode*, struct stat*);
-int             writei(struct inode*, char*, uint, uint);
+void readsb(int dev, struct superblock *sb);
+int dirlink(struct inode *, char *, uint);
+struct inode *dirlookup(struct inode *, char *, uint *);
+struct inode *ialloc(uint, short);
+struct inode *idup(struct inode *);
+void iinit(int dev);
+void ilock(struct inode *);
+void iput(struct inode *);
+void iunlock(struct inode *);
+void iunlockput(struct inode *);
+void iupdate(struct inode *);
+int namecmp(const char *, const char *);
+struct inode *namei(char *);
+struct inode *nameiparent(char *, char *);
+int readi(struct inode *, char *, uint, uint);
+void stati(struct inode *, struct stat *);
+int writei(struct inode *, char *, uint, uint);
 
 // ide.c
-void            ideinit(void);
-void            ideintr(void);
-void            iderw(struct buf*);
+void ideinit(void);
+void ideintr(void);
+void iderw(struct buf *);
 
 // ioapic.c
-void            ioapicenable(int irq, int cpu);
-extern uchar    ioapicid;
-void            ioapicinit(void);
+void ioapicenable(int irq, int cpu);
+extern uchar ioapicid;
+void ioapicinit(void);
 
 // kalloc.c
-char*           kalloc(void);
-void            kfree(char*);
-void            kinit1(void*, void*);
-void            kinit2(void*, void*);
+char *kalloc(void);
+void kfree(char *);
+void kinit1(void *, void *);
+void kinit2(void *, void *);
 
 // kbd.c
-void            kbdintr(void);
+void kbdintr(void);
 
 // lapic.c
-void            cmostime(struct rtcdate *r);
-int             lapicid(void);
-extern volatile uint*    lapic;
-void            lapiceoi(void);
-void            lapicinit(void);
-void            lapicstartap(uchar, uint);
-void            microdelay(int);
+void cmostime(struct rtcdate *r);
+int lapicid(void);
+extern volatile uint *lapic;
+void lapiceoi(void);
+void lapicinit(void);
+void lapicstartap(uchar, uint);
+void microdelay(int);
 
 // log.c
-void            initlog(int dev);
-void            log_write(struct buf*);
-void            begin_op();
-void            end_op();
+void initlog(int dev);
+void log_write(struct buf *);
+void begin_op();
+void end_op();
 
 // mp.c
-extern int      ismp;
-void            mpinit(void);
+extern int ismp;
+void mpinit(void);
 
 // picirq.c
-void            picenable(int);
-void            picinit(void);
+void picenable(int);
+void picinit(void);
 
 // pipe.c
-int             pipealloc(struct file**, struct file**);
-void            pipeclose(struct pipe*, int);
-int             piperead(struct pipe*, char*, int);
-int             pipewrite(struct pipe*, char*, int);
-
-//PAGEBREAK: 16
-// proc.c
-int             cpuid(void);
-void            exit(void);
-int             fork(void);
-int             growproc(int);
-int             kill(int);
-struct cpu*     mycpu(void);
-struct proc*    myproc();
-void            pinit(void);
-void            procdump(void);
-void            scheduler(void) __attribute__((noreturn));
-void            sched(void);
-void            setproc(struct proc*);
-void            sleep(void*, struct spinlock*);
-void            userinit(void);
-int             wait(void);
-void            wakeup(void*);
-void            yield(void);
+int pipealloc(struct file **, struct file **);
+void pipeclose(struct pipe *, int);
+int piperead(struct pipe *, char *, int);
+int pipewrite(struct pipe *, char *, int);
+
+// PAGEBREAK: 16
+//  proc.c
+int cpuid(void);
+void exit(void);
+int fork(void);
+int growproc(int);
+int kill(int);
+struct cpu *mycpu(void);
+struct proc *myproc();
+void pinit(void);
+void procdump(void);
+void scheduler(void) __attribute__((noreturn));
+void sched(void);
+void setproc(struct proc *);
+void sleep(void *, struct spinlock *);
+void userinit(void);
+int wait(void);
+void wakeup(void *);
+void yield(void);
+int thread_create(void (*)(void *), void *, void *);
+int thread_join(void);
+int thread_exit(void);
+void thread_spinlock_init(struct spinlock *);
+void thread_spin_lock(struct spinlock *);
+void thread_spin_unlock(struct spinlock *);
 
 // swtch.S
-void            swtch(struct context**, struct context*);
+void swtch(struct context **, struct context *);
 
 // spinlock.c
-void            acquire(struct spinlock*);
-void            getcallerpcs(void*, uint*);
-int             holding(struct spinlock*);
-void            initlock(struct spinlock*, char*);
-void            release(struct spinlock*);
-void            pushcli(void);
-void            popcli(void);
+void acquire(struct spinlock *);
+void getcallerpcs(void *, uint *);
+int holding(struct spinlock *);
+void initlock(struct spinlock *, char *);
+void release(struct spinlock *);
+void pushcli(void);
+void popcli(void);
 
 // sleeplock.c
-void            acquiresleep(struct sleeplock*);
-void            releasesleep(struct sleeplock*);
-int             holdingsleep(struct sleeplock*);
-void            initsleeplock(struct sleeplock*, char*);
+void acquiresleep(struct sleeplock *);
+void releasesleep(struct sleeplock *);
+int holdingsleep(struct sleeplock *);
+void initsleeplock(struct sleeplock *, char *);
 
 // string.c
-int             memcmp(const void*, const void*, uint);
-void*           memmove(void*, const void*, uint);
-void*           memset(void*, int, uint);
-char*           safestrcpy(char*, const char*, int);
-int             strlen(const char*);
-int             strncmp(const char*, const char*, uint);
-char*           strncpy(char*, const char*, int);
+int memcmp(const void *, const void *, uint);
+void *memmove(void *, const void *, uint);
+void *memset(void *, int, uint);
+char *safestrcpy(char *, const char *, int);
+int strlen(const char *);
+int strncmp(const char *, const char *, uint);
+char *strncpy(char *, const char *, int);
 
 // syscall.c
-int             argint(int, int*);
-int             argptr(int, char**, int);
-int             argstr(int, char**);
-int             fetchint(uint, int*);
-int             fetchstr(uint, char**);
-void            syscall(void);
+int argint(int, int *);
+int argptr(int, char **, int);
+int argstr(int, char **);
+int fetchint(uint, int *);
+int fetchstr(uint, char **);
+void syscall(void);
 
 // timer.c
-void            timerinit(void);
+void timerinit(void);
 
 // trap.c
-void            idtinit(void);
-extern uint     ticks;
-void            tvinit(void);
+void idtinit(void);
+extern uint ticks;
+void tvinit(void);
 extern struct spinlock tickslock;
 
 // uart.c
-void            uartinit(void);
-void            uartintr(void);
-void            uartputc(int);
+void uartinit(void);
+void uartintr(void);
+void uartputc(int);
 
 // vm.c
-void            seginit(void);
-void            kvmalloc(void);
-pde_t*          setupkvm(void);
-char*           uva2ka(pde_t*, char*);
-int             allocuvm(pde_t*, uint, uint);
-int             deallocuvm(pde_t*, uint, uint);
-void            freevm(pde_t*);
-void            inituvm(pde_t*, char*, uint);
-int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
-pde_t*          copyuvm(pde_t*, uint);
-void            switchuvm(struct proc*);
-void            switchkvm(void);
-int             copyout(pde_t*, uint, void*, uint);
-void            clearpteu(pde_t *pgdir, char *uva);
+void seginit(void);
+void kvmalloc(void);
+pde_t *setupkvm(void);
+char *uva2ka(pde_t *, char *);
+int allocuvm(pde_t *, uint, uint);
+int deallocuvm(pde_t *, uint, uint);
+void freevm(pde_t *);
+void inituvm(pde_t *, char *, uint);
+int loaduvm(pde_t *, char *, struct inode *, uint, uint);
+pde_t *copyuvm(pde_t *, uint);
+void switchuvm(struct proc *);
+void switchkvm(void);
+int copyout(pde_t *, uint, void *, uint);
+void clearpteu(pde_t *pgdir, char *uva);
 
 // number of elements in fixed-size array
-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+#define NELEM(x) (sizeof(x) / sizeof((x)[0]))
diff --git a/mutex.c b/mutex.c
new file mode 100644
index 0000000..be29c98
--- /dev/null
+++ b/mutex.c
@@ -0,0 +1,24 @@
+#include "types.h"
+#include "user.h"
+#include "x86.h"
+
+void thread_mutex_init(struct mutexlock *lk, char *name)
+{
+    lk->locked = 0;
+    lk->name = name;
+}
+
+void thread_mutex_lock(struct mutexlock *lk)
+{
+    while (xchg(&lk->locked, 1))
+    {
+        sleep(1);
+    }
+}
+
+void thread_mutex_unlock(struct mutexlock *lk)
+{
+    asm volatile("movl $0, %0"
+                 : "+m"(lk->locked)
+                 :);
+}
\ No newline at end of file
diff --git a/mutex.h b/mutex.h
new file mode 100644
index 0000000..d33cf8e
--- /dev/null
+++ b/mutex.h
@@ -0,0 +1,6 @@
+#include "types.h"
+
+struct mutexlock{
+    uint locked;
+    char* name;
+};
\ No newline at end of file
diff --git a/proc.c b/proc.c
index 806b1b1..6f3bd9b 100644
--- a/proc.c
+++ b/proc.c
@@ -7,9 +7,10 @@
 #include "proc.h"
 #include "spinlock.h"
 
-struct {
-  struct spinlock lock;
-  struct proc proc[NPROC];
+struct
+{
+    struct spinlock lock;
+    struct proc proc[NPROC];
 } ptable;
 
 static struct proc *initproc;
@@ -20,339 +21,349 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
-void
-pinit(void)
+void pinit(void)
 {
-  initlock(&ptable.lock, "ptable");
+    initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
+int cpuid()
+{
+    return mycpu() - cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu*
+struct cpu *
 mycpu(void)
 {
-  int apicid, i;
-  
-  if(readeflags()&FL_IF)
-    panic("mycpu called with interrupts enabled\n");
-  
-  apicid = lapicid();
-  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
-  // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
-    if (cpus[i].apicid == apicid)
-      return &cpus[i];
-  }
-  panic("unknown apicid\n");
+    int apicid, i;
+
+    if (readeflags() & FL_IF)
+        panic("mycpu called with interrupts enabled\n");
+
+    apicid = lapicid();
+    // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+    // a reverse map, or reserve a register to store &cpus[i].
+    for (i = 0; i < ncpu; ++i)
+    {
+        if (cpus[i].apicid == apicid)
+            return &cpus[i];
+    }
+    panic("unknown apicid\n");
 }
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc*
-myproc(void) {
-  struct cpu *c;
-  struct proc *p;
-  pushcli();
-  c = mycpu();
-  p = c->proc;
-  popcli();
-  return p;
+struct proc *
+myproc(void)
+{
+    struct cpu *c;
+    struct proc *p;
+    pushcli();
+    c = mycpu();
+    p = c->proc;
+    popcli();
+    return p;
 }
 
-//PAGEBREAK: 32
-// Look in the process table for an UNUSED proc.
-// If found, change state to EMBRYO and initialize
-// state required to run in the kernel.
-// Otherwise return 0.
-static struct proc*
+// PAGEBREAK: 32
+//  Look in the process table for an UNUSED proc.
+//  If found, change state to EMBRYO and initialize
+//  state required to run in the kernel.
+//  Otherwise return 0.
+static struct proc *
 allocproc(void)
 {
-  struct proc *p;
-  char *sp;
+    struct proc *p;
+    char *sp;
 
-  acquire(&ptable.lock);
+    acquire(&ptable.lock);
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
-      goto found;
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+        if (p->state == UNUSED)
+            goto found;
 
-  release(&ptable.lock);
-  return 0;
+    release(&ptable.lock);
+    return 0;
 
 found:
-  p->state = EMBRYO;
-  p->pid = nextpid++;
+    p->state = EMBRYO;
+    p->pid = nextpid++;
 
-  release(&ptable.lock);
+    release(&ptable.lock);
 
-  // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
-    p->state = UNUSED;
-    return 0;
-  }
-  sp = p->kstack + KSTACKSIZE;
+    // Allocate kernel stack.
+    if ((p->kstack = kalloc()) == 0)
+    {
+        p->state = UNUSED;
+        return 0;
+    }
+    sp = p->kstack + KSTACKSIZE;
 
-  // Leave room for trap frame.
-  sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+    // Leave room for trap frame.
+    sp -= sizeof *p->tf;
+    p->tf = (struct trapframe *)sp;
 
-  // Set up new context to start executing at forkret,
-  // which returns to trapret.
-  sp -= 4;
-  *(uint*)sp = (uint)trapret;
+    // Set up new context to start executing at forkret,
+    // which returns to trapret.
+    sp -= 4;
+    *(uint *)sp = (uint)trapret;
 
-  sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
-  memset(p->context, 0, sizeof *p->context);
-  p->context->eip = (uint)forkret;
+    sp -= sizeof *p->context;
+    p->context = (struct context *)sp;
+    memset(p->context, 0, sizeof *p->context);
+    p->context->eip = (uint)forkret;
 
-  return p;
+    return p;
 }
 
-//PAGEBREAK: 32
-// Set up first user process.
-void
-userinit(void)
+// PAGEBREAK: 32
+//  Set up first user process.
+void userinit(void)
 {
-  struct proc *p;
-  extern char _binary_initcode_start[], _binary_initcode_size[];
-
-  p = allocproc();
-  
-  initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
-    panic("userinit: out of memory?");
-  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
-  p->sz = PGSIZE;
-  memset(p->tf, 0, sizeof(*p->tf));
-  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-  p->tf->es = p->tf->ds;
-  p->tf->ss = p->tf->ds;
-  p->tf->eflags = FL_IF;
-  p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
-
-  safestrcpy(p->name, "initcode", sizeof(p->name));
-  p->cwd = namei("/");
-
-  // this assignment to p->state lets other cores
-  // run this process. the acquire forces the above
-  // writes to be visible, and the lock is also needed
-  // because the assignment might not be atomic.
-  acquire(&ptable.lock);
-
-  p->state = RUNNABLE;
-
-  release(&ptable.lock);
+    struct proc *p;
+    extern char _binary_initcode_start[], _binary_initcode_size[];
+
+    p = allocproc();
+
+    initproc = p;
+    if ((p->pgdir = setupkvm()) == 0)
+        panic("userinit: out of memory?");
+    inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+    p->sz = PGSIZE;
+    memset(p->tf, 0, sizeof(*p->tf));
+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+    p->tf->es = p->tf->ds;
+    p->tf->ss = p->tf->ds;
+    p->tf->eflags = FL_IF;
+    p->tf->esp = PGSIZE;
+    p->tf->eip = 0; // beginning of initcode.S
+
+    safestrcpy(p->name, "initcode", sizeof(p->name));
+    p->cwd = namei("/");
+
+    // this assignment to p->state lets other cores
+    // run this process. the acquire forces the above
+    // writes to be visible, and the lock is also needed
+    // because the assignment might not be atomic.
+    acquire(&ptable.lock);
+
+    p->state = RUNNABLE;
+
+    release(&ptable.lock);
 }
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
-int
-growproc(int n)
+int growproc(int n)
 {
-  uint sz;
-  struct proc *curproc = myproc();
-
-  sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  }
-  curproc->sz = sz;
-  switchuvm(curproc);
-  return 0;
+    uint sz;
+    struct proc *curproc = myproc();
+
+    sz = curproc->sz;
+    if (n > 0)
+    {
+        if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+            return -1;
+    }
+    else if (n < 0)
+    {
+        if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+            return -1;
+    }
+    curproc->sz = sz;
+    switchuvm(curproc);
+    return 0;
 }
 
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
-int
-fork(void)
+int fork(void)
 {
-  int i, pid;
-  struct proc *np;
-  struct proc *curproc = myproc();
-
-  // Allocate process.
-  if((np = allocproc()) == 0){
-    return -1;
-  }
+    int i, pid;
+    struct proc *np;
+    struct proc *curproc = myproc();
+
+    // Allocate process.
+    if ((np = allocproc()) == 0)
+    {
+        return -1;
+    }
 
-  // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
-    kfree(np->kstack);
-    np->kstack = 0;
-    np->state = UNUSED;
-    return -1;
-  }
-  np->sz = curproc->sz;
-  np->parent = curproc;
-  *np->tf = *curproc->tf;
+    // Copy process state from proc.
+    if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
+    {
+        kfree(np->kstack);
+        np->kstack = 0;
+        np->state = UNUSED;
+        return -1;
+    }
+    np->sz = curproc->sz;
+    np->parent = curproc;
+    *np->tf = *curproc->tf;
 
-  // Clear %eax so that fork returns 0 in the child.
-  np->tf->eax = 0;
+    // Clear %eax so that fork returns 0 in the child.
+    np->tf->eax = 0;
 
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
-      np->ofile[i] = filedup(curproc->ofile[i]);
-  np->cwd = idup(curproc->cwd);
+    for (i = 0; i < NOFILE; i++)
+        if (curproc->ofile[i])
+            np->ofile[i] = filedup(curproc->ofile[i]);
+    np->cwd = idup(curproc->cwd);
 
-  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
 
-  pid = np->pid;
+    pid = np->pid;
 
-  acquire(&ptable.lock);
+    acquire(&ptable.lock);
 
-  np->state = RUNNABLE;
+    np->state = RUNNABLE;
 
-  release(&ptable.lock);
+    release(&ptable.lock);
 
-  return pid;
+    return pid;
 }
 
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
+void exit(void)
 {
-  struct proc *curproc = myproc();
-  struct proc *p;
-  int fd;
-
-  if(curproc == initproc)
-    panic("init exiting");
-
-  // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
-      fileclose(curproc->ofile[fd]);
-      curproc->ofile[fd] = 0;
+    struct proc *curproc = myproc();
+    struct proc *p;
+    int fd;
+
+    if (curproc == initproc)
+        panic("init exiting");
+
+    // Close all open files.
+    for (fd = 0; fd < NOFILE; fd++)
+    {
+        if (curproc->ofile[fd])
+        {
+            fileclose(curproc->ofile[fd]);
+            curproc->ofile[fd] = 0;
+        }
     }
-  }
-
-  begin_op();
-  iput(curproc->cwd);
-  end_op();
-  curproc->cwd = 0;
 
-  acquire(&ptable.lock);
+    begin_op();
+    iput(curproc->cwd);
+    end_op();
+    curproc->cwd = 0;
 
-  // Parent might be sleeping in wait().
-  wakeup1(curproc->parent);
+    acquire(&ptable.lock);
 
-  // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
-      p->parent = initproc;
-      if(p->state == ZOMBIE)
-        wakeup1(initproc);
+    // Parent might be sleeping in wait().
+    wakeup1(curproc->parent);
+
+    // Pass abandoned children to init.
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+        if (p->parent == curproc)
+        {
+            p->parent = initproc;
+            if (p->state == ZOMBIE)
+                wakeup1(initproc);
+        }
     }
-  }
 
-  // Jump into the scheduler, never to return.
-  curproc->state = ZOMBIE;
-  sched();
-  panic("zombie exit");
+    // Jump into the scheduler, never to return.
+    curproc->state = ZOMBIE;
+    sched();
+    panic("zombie exit");
 }
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(void)
+int wait(void)
 {
-  struct proc *p;
-  int havekids, pid;
-  struct proc *curproc = myproc();
-  
-  acquire(&ptable.lock);
-  for(;;){
-    // Scan through table looking for exited children.
-    havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
-        continue;
-      havekids = 1;
-      if(p->state == ZOMBIE){
-        // Found one.
-        pid = p->pid;
-        kfree(p->kstack);
-        p->kstack = 0;
-        freevm(p->pgdir);
-        p->pid = 0;
-        p->parent = 0;
-        p->name[0] = 0;
-        p->killed = 0;
-        p->state = UNUSED;
-        release(&ptable.lock);
-        return pid;
-      }
-    }
+    struct proc *p;
+    int havekids, pid;
+    struct proc *curproc = myproc();
 
-    // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
-      release(&ptable.lock);
-      return -1;
+    acquire(&ptable.lock);
+    for (;;)
+    {
+        // Scan through table looking for exited children.
+        havekids = 0;
+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+        {
+            if (p->parent != curproc)
+                continue;
+            havekids = 1;
+            if (p->state == ZOMBIE)
+            {
+                // Found one.
+                pid = p->pid;
+                kfree(p->kstack);
+                p->kstack = 0;
+                freevm(p->pgdir);
+                p->pid = 0;
+                p->parent = 0;
+                p->name[0] = 0;
+                p->killed = 0;
+                p->state = UNUSED;
+                release(&ptable.lock);
+                return pid;
+            }
+        }
+
+        // No point waiting if we don't have any children.
+        if (!havekids || curproc->killed)
+        {
+            release(&ptable.lock);
+            return -1;
+        }
+
+        // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+        sleep(curproc, &ptable.lock); // DOC: wait-sleep
     }
-
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
-  }
 }
 
-//PAGEBREAK: 42
-// Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
-// Scheduler never returns.  It loops, doing:
-//  - choose a process to run
-//  - swtch to start running that process
-//  - eventually that process transfers control
-//      via swtch back to the scheduler.
-void
-scheduler(void)
+// PAGEBREAK: 42
+//  Per-CPU process scheduler.
+//  Each CPU calls scheduler() after setting itself up.
+//  Scheduler never returns.  It loops, doing:
+//   - choose a process to run
+//   - swtch to start running that process
+//   - eventually that process transfers control
+//       via swtch back to the scheduler.
+void scheduler(void)
 {
-  struct proc *p;
-  struct cpu *c = mycpu();
-  c->proc = 0;
-  
-  for(;;){
-    // Enable interrupts on this processor.
-    sti();
-
-    // Loop over process table looking for process to run.
-    acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
-
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      c->proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-
-      swtch(&(c->scheduler), p->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      c->proc = 0;
+    struct proc *p;
+    struct cpu *c = mycpu();
+    c->proc = 0;
+
+    for (;;)
+    {
+        // Enable interrupts on this processor.
+        sti();
+
+        // Loop over process table looking for process to run.
+        acquire(&ptable.lock);
+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+        {
+            if (p->state != RUNNABLE)
+                continue;
+
+            // Switch to chosen process.  It is the process's job
+            // to release ptable.lock and then reacquire it
+            // before jumping back to us.
+            c->proc = p;
+            switchuvm(p);
+            p->state = RUNNING;
+
+            swtch(&(c->scheduler), p->context);
+            switchkvm();
+
+            // Process is done running for now.
+            // It should have changed its p->state before coming back.
+            c->proc = 0;
+        }
+        release(&ptable.lock);
     }
-    release(&ptable.lock);
-
-  }
 }
 
 // Enter scheduler.  Must hold only ptable.lock
@@ -362,173 +373,338 @@ scheduler(void)
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
+void sched(void)
 {
-  int intena;
-  struct proc *p = myproc();
-
-  if(!holding(&ptable.lock))
-    panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
-    panic("sched locks");
-  if(p->state == RUNNING)
-    panic("sched running");
-  if(readeflags()&FL_IF)
-    panic("sched interruptible");
-  intena = mycpu()->intena;
-  swtch(&p->context, mycpu()->scheduler);
-  mycpu()->intena = intena;
+    int intena;
+    struct proc *p = myproc();
+
+    if (!holding(&ptable.lock))
+        panic("sched ptable.lock");
+    if (mycpu()->ncli != 1)
+        panic("sched locks");
+    if (p->state == RUNNING)
+        panic("sched running");
+    if (readeflags() & FL_IF)
+        panic("sched interruptible");
+    intena = mycpu()->intena;
+    swtch(&p->context, mycpu()->scheduler);
+    mycpu()->intena = intena;
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
+void yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
-  myproc()->state = RUNNABLE;
-  sched();
-  release(&ptable.lock);
+    acquire(&ptable.lock); // DOC: yieldlock
+    myproc()->state = RUNNABLE;
+    sched();
+    release(&ptable.lock);
 }
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
-void
-forkret(void)
+void forkret(void)
 {
-  static int first = 1;
-  // Still holding ptable.lock from scheduler.
-  release(&ptable.lock);
-
-  if (first) {
-    // Some initialization functions must be run in the context
-    // of a regular process (e.g., they call sleep), and thus cannot
-    // be run from main().
-    first = 0;
-    iinit(ROOTDEV);
-    initlog(ROOTDEV);
-  }
-
-  // Return to "caller", actually trapret (see allocproc).
+    static int first = 1;
+    // Still holding ptable.lock from scheduler.
+    release(&ptable.lock);
+
+    if (first)
+    {
+        // Some initialization functions must be run in the context
+        // of a regular process (e.g., they call sleep), and thus cannot
+        // be run from main().
+        first = 0;
+        iinit(ROOTDEV);
+        initlog(ROOTDEV);
+    }
+
+    // Return to "caller", actually trapret (see allocproc).
 }
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
+void sleep(void *chan, struct spinlock *lk)
 {
-  struct proc *p = myproc();
-  
-  if(p == 0)
-    panic("sleep");
-
-  if(lk == 0)
-    panic("sleep without lk");
-
-  // Must acquire ptable.lock in order to
-  // change p->state and then call sched.
-  // Once we hold ptable.lock, we can be
-  // guaranteed that we won't miss any wakeup
-  // (wakeup runs with ptable.lock locked),
-  // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
-    release(lk);
-  }
-  // Go to sleep.
-  p->chan = chan;
-  p->state = SLEEPING;
-
-  sched();
-
-  // Tidy up.
-  p->chan = 0;
-
-  // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
-    release(&ptable.lock);
-    acquire(lk);
-  }
+    struct proc *p = myproc();
+
+    if (p == 0)
+        panic("sleep");
+
+    if (lk == 0)
+        panic("sleep without lk");
+
+    // Must acquire ptable.lock in order to
+    // change p->state and then call sched.
+    // Once we hold ptable.lock, we can be
+    // guaranteed that we won't miss any wakeup
+    // (wakeup runs with ptable.lock locked),
+    // so it's okay to release lk.
+    if (lk != &ptable.lock)
+    {                          // DOC: sleeplock0
+        acquire(&ptable.lock); // DOC: sleeplock1
+        release(lk);
+    }
+    // Go to sleep.
+    p->chan = chan;
+    p->state = SLEEPING;
+
+    sched();
+
+    // Tidy up.
+    p->chan = 0;
+
+    // Reacquire original lock.
+    if (lk != &ptable.lock)
+    { // DOC: sleeplock2
+        release(&ptable.lock);
+        acquire(lk);
+    }
 }
 
-//PAGEBREAK!
-// Wake up all processes sleeping on chan.
-// The ptable lock must be held.
+// PAGEBREAK!
+//  Wake up all processes sleeping on chan.
+//  The ptable lock must be held.
 static void
 wakeup1(void *chan)
 {
-  struct proc *p;
+    struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+        if (p->state == SLEEPING && p->chan == chan)
+            p->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
+void wakeup(void *chan)
 {
-  acquire(&ptable.lock);
-  wakeup1(chan);
-  release(&ptable.lock);
+    acquire(&ptable.lock);
+    wakeup1(chan);
+    release(&ptable.lock);
 }
 
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int
-kill(int pid)
+int kill(int pid)
 {
-  struct proc *p;
-
-  acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
-      p->killed = 1;
-      // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
-        p->state = RUNNABLE;
-      release(&ptable.lock);
-      return 0;
+    struct proc *p;
+
+    acquire(&ptable.lock);
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+        if (p->pid == pid)
+        {
+            p->killed = 1;
+            // Wake process from sleep if necessary.
+            if (p->state == SLEEPING)
+                p->state = RUNNABLE;
+            release(&ptable.lock);
+            return 0;
+        }
+    }
+    release(&ptable.lock);
+    return -1;
+}
+
+// PAGEBREAK: 36
+//  Print a process listing to console.  For debugging.
+//  Runs when user types ^P on console.
+//  No lock to avoid wedging a stuck machine further.
+void procdump(void)
+{
+    static char *states[] = {
+        [UNUSED] "unused",
+        [EMBRYO] "embryo",
+        [SLEEPING] "sleep ",
+        [RUNNABLE] "runble",
+        [RUNNING] "run   ",
+        [ZOMBIE] "zombie"};
+    int i;
+    struct proc *p;
+    char *state;
+    uint pc[10];
+
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+        if (p->state == UNUSED)
+            continue;
+        if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+            state = states[p->state];
+        else
+            state = "???";
+        cprintf("%d %s %s", p->pid, state, p->name);
+        if (p->state == SLEEPING)
+        {
+            getcallerpcs((uint *)p->context->ebp + 2, pc);
+            for (i = 0; i < 10 && pc[i] != 0; i++)
+                cprintf(" %p", pc[i]);
+        }
+        cprintf("\n");
+    }
+}
+
+int thread_create(void (*fcn)(void *), void *arg, void *stack)
+{
+    int i, pid;
+    struct proc *np;
+    struct proc *curproc = myproc();
+
+    // Allocate process.
+    if ((np = allocproc()) == 0)
+    {
+        return -1;
+    }
+
+    np->sz = curproc->sz;
+    np->parent = curproc;
+
+    np->pgdir = curproc->pgdir;
+    *np->tf = *curproc->tf;
+    // *np->context = *curproc->context;   // Saving in context is giving error
+    np->tf->eax = 0;
+    np->tf->eip = (uint)fcn;
+    // np->stack = (uint)stack;
+    np->tf->esp = (uint)stack + 4092;
+    *((uint *)(np->tf->esp)) = (uint)arg;
+    *((uint *)(np->tf->esp - 4)) = 0xFFFFFFFF;
+    np->tf->esp -= 4;
+
+    for (i = 0; i < NOFILE; i++)
+        if (curproc->ofile[i])
+            np->ofile[i] = filedup(curproc->ofile[i]);
+    np->cwd = idup(curproc->cwd);
+
+    safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+
+    pid = np->pid;
+
+    acquire(&ptable.lock);
+
+    np->state = RUNNABLE;
+    release(&ptable.lock);
+    return pid;
+}
+
+int thread_join(void)
+{
+
+    struct proc *p;
+    int havekids, pid;
+    struct proc *curproc = myproc();
+
+    acquire(&ptable.lock);
+
+    while (1)
+    {
+        havekids = 0;
+        for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+        {
+            if (p->parent != curproc)
+                continue;
+            havekids = 1;
+            if (p->state == ZOMBIE)
+            {
+                pid = p->pid;
+                kfree(p->kstack);
+                p->kstack = 0;
+                p->state = UNUSED;
+                p->pid = 0;
+                p->parent = 0;
+                p->name[0] = 0;
+                p->killed = 0;
+                release(&ptable.lock);
+                return pid;
+            }
+        }
+
+        if (!havekids || curproc->killed)
+        {
+            release(&ptable.lock);
+            return -1;
+        }
+        sleep(curproc, &ptable.lock);
     }
-  }
-  release(&ptable.lock);
-  return -1;
 }
 
-//PAGEBREAK: 36
-// Print a process listing to console.  For debugging.
-// Runs when user types ^P on console.
-// No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
+int thread_exit(void)
 {
-  static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
-  int i;
-  struct proc *p;
-  char *state;
-  uint pc[10];
-
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
-      continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
-      state = states[p->state];
-    else
-      state = "???";
-    cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
-        cprintf(" %p", pc[i]);
+
+    struct proc *p;
+    struct proc *curproc = myproc();
+    int fd;
+
+    if (curproc == initproc)
+        panic("init exiting");
+
+    for (fd = 0; fd < NOFILE; fd++)
+    {
+        if (curproc->ofile[fd])
+        {
+            fileclose(curproc->ofile[fd]);
+            curproc->ofile[fd] = 0;
+        }
     }
-    cprintf("\n");
-  }
+
+    begin_op();
+    iput(curproc->cwd);
+    end_op();
+    curproc->cwd = 0;
+
+    acquire(&ptable.lock);
+
+    // Parent might be sleeping in wait().
+    wakeup1(curproc->parent);
+
+    // Pass abandoned children to init.
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+        if (p->parent == curproc)
+        {
+            p->parent = initproc;
+            if (p->state == ZOMBIE)
+                wakeup1(initproc);
+        }
+    }
+
+    // Jump into the scheduler, never to return.
+    curproc->state = ZOMBIE;
+    sched();
+    panic("zombie exit");
+}
+
+void thread_spinlock_init(struct spinlock *lk)
+{
+    initlock(lk, "tlock");
 }
+
+void thread_spin_lock(struct spinlock *lk)
+{
+
+    // while(holding(lk));
+    // lk->locked = 1;
+
+    // Eariler using the above commented code was resulting in problems
+    // due to lack of atomicity
+    // This resulted in very long busy waits
+
+    // acquire(lk);
+
+    // Ask the reason why acquire and release is not working
+
+    while (xchg(&lk->locked, 1))
+        ;
+
+    // xchg is atomic and executes lock operation completely
+    // before context swit
+}
+
+void thread_spin_unlock(struct spinlock *lk)
+{
+    // lk->locked = 0;
+
+    // release(lk);
+
+    asm volatile("movl $0, %0"
+                 : "+m"(lk->locked)
+                 :);
+}
\ No newline at end of file
diff --git a/syscall.c b/syscall.c
index ee85261..8e3d626 100644
--- a/syscall.c
+++ b/syscall.c
@@ -14,72 +14,68 @@
 // to a saved program counter, and then the first argument.
 
 // Fetch the int at addr from the current process.
-int
-fetchint(uint addr, int *ip)
+int fetchint(uint addr, int *ip)
 {
-  struct proc *curproc = myproc();
+    struct proc *curproc = myproc();
 
-  if(addr >= curproc->sz || addr+4 > curproc->sz)
-    return -1;
-  *ip = *(int*)(addr);
-  return 0;
+    if (addr >= curproc->sz || addr + 4 > curproc->sz)
+        return -1;
+    *ip = *(int *)(addr);
+    return 0;
 }
 
 // Fetch the nul-terminated string at addr from the current process.
 // Doesn't actually copy the string - just sets *pp to point at it.
 // Returns length of string, not including nul.
-int
-fetchstr(uint addr, char **pp)
+int fetchstr(uint addr, char **pp)
 {
-  char *s, *ep;
-  struct proc *curproc = myproc();
+    char *s, *ep;
+    struct proc *curproc = myproc();
 
-  if(addr >= curproc->sz)
+    if (addr >= curproc->sz)
+        return -1;
+    *pp = (char *)addr;
+    ep = (char *)curproc->sz;
+    for (s = *pp; s < ep; s++)
+    {
+        if (*s == 0)
+            return s - *pp;
+    }
     return -1;
-  *pp = (char*)addr;
-  ep = (char*)curproc->sz;
-  for(s = *pp; s < ep; s++){
-    if(*s == 0)
-      return s - *pp;
-  }
-  return -1;
 }
 
 // Fetch the nth 32-bit system call argument.
-int
-argint(int n, int *ip)
+int argint(int n, int *ip)
 {
-  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+    return fetchint((myproc()->tf->esp) + 4 + 4 * n, ip);
 }
 
 // Fetch the nth word-sized system call argument as a pointer
 // to a block of memory of size bytes.  Check that the pointer
 // lies within the process address space.
-int
-argptr(int n, char **pp, int size)
+int argptr(int n, char **pp, int size)
 {
-  int i;
-  struct proc *curproc = myproc();
- 
-  if(argint(n, &i) < 0)
-    return -1;
-  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
-    return -1;
-  *pp = (char*)i;
-  return 0;
+    int i;
+    struct proc *curproc = myproc();
+
+    if (argint(n, &i) < 0)
+        return -1;
+    if (size < 0 || (uint)i >= curproc->sz || (uint)i + size > curproc->sz)
+        return -1;
+    *pp = (char *)i;
+    return 0;
 }
 
 // Fetch the nth word-sized system call argument as a string pointer.
 // Check that the pointer is valid and the string is nul-terminated.
 // (There is no shared writable memory, so the string can't change
 // between this check and being used by the kernel.)
-int
-argstr(int n, char **pp)
+int argstr(int n, char **pp)
 {
-  int addr;
-  if(argint(n, &addr) < 0)
-    return -1;
-  return fetchstr(addr, pp);
+    int addr;
+    if (argint(n, &addr) < 0)
+        return -1;
+    return fetchstr(addr, pp);
 }
 
 extern int sys_chdir(void);
@@ -103,43 +99,63 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_thread_create(void);
+extern int sys_thread_join(void);
+extern int sys_thread_exit(void);
+extern int sys_thread_test(void);
+extern int sys_thread_test_spinlock(void);
+extern int sys_thread_test_mutex(void);
+extern int sys_thread_spinlock_init(void);
+extern int sys_thread_spin_lock(void);
+extern int sys_thread_spin_unlock(void);
 
 static int (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+    [SYS_fork] sys_fork,
+    [SYS_exit] sys_exit,
+    [SYS_wait] sys_wait,
+    [SYS_pipe] sys_pipe,
+    [SYS_read] sys_read,
+    [SYS_kill] sys_kill,
+    [SYS_exec] sys_exec,
+    [SYS_fstat] sys_fstat,
+    [SYS_chdir] sys_chdir,
+    [SYS_dup] sys_dup,
+    [SYS_getpid] sys_getpid,
+    [SYS_sbrk] sys_sbrk,
+    [SYS_sleep] sys_sleep,
+    [SYS_uptime] sys_uptime,
+    [SYS_open] sys_open,
+    [SYS_write] sys_write,
+    [SYS_mknod] sys_mknod,
+    [SYS_unlink] sys_unlink,
+    [SYS_link] sys_link,
+    [SYS_mkdir] sys_mkdir,
+    [SYS_close] sys_close,
+    [SYS_thread_create] sys_thread_create,
+    [SYS_thread_join] sys_thread_join,
+    [SYS_thread_exit] sys_thread_exit,
+    [SYS_thread_test] sys_thread_test,
+    [SYS_thread_test_spinlock] sys_thread_test_spinlock,
+    [SYS_thread_test_mutex] sys_thread_test_mutex,
+    [SYS_thread_spinlock_init] sys_thread_spinlock_init,
+    [SYS_thread_spin_lock] sys_thread_spin_lock,
+    [SYS_thread_spin_unlock] sys_thread_spin_unlock,
 };
 
-void
-syscall(void)
+void syscall(void)
 {
-  int num;
-  struct proc *curproc = myproc();
+    int num;
+    struct proc *curproc = myproc();
 
-  num = curproc->tf->eax;
-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
-    curproc->tf->eax = syscalls[num]();
-  } else {
-    cprintf("%d %s: unknown sys call %d\n",
-            curproc->pid, curproc->name, num);
-    curproc->tf->eax = -1;
-  }
+    num = curproc->tf->eax;
+    if (num > 0 && num < NELEM(syscalls) && syscalls[num])
+    {
+        curproc->tf->eax = syscalls[num]();
+    }
+    else
+    {
+        cprintf("%d %s: unknown sys call %d\n",
+                curproc->pid, curproc->name, num);
+        curproc->tf->eax = -1;
+    }
 }
diff --git a/syscall.h b/syscall.h
index bc5f356..0992660 100644
--- a/syscall.h
+++ b/syscall.h
@@ -1,22 +1,31 @@
 // System call numbers
-#define SYS_fork    1
-#define SYS_exit    2
-#define SYS_wait    3
-#define SYS_pipe    4
-#define SYS_read    5
-#define SYS_kill    6
-#define SYS_exec    7
-#define SYS_fstat   8
-#define SYS_chdir   9
-#define SYS_dup    10
+#define SYS_fork 1
+#define SYS_exit 2
+#define SYS_wait 3
+#define SYS_pipe 4
+#define SYS_read 5
+#define SYS_kill 6
+#define SYS_exec 7
+#define SYS_fstat 8
+#define SYS_chdir 9
+#define SYS_dup 10
 #define SYS_getpid 11
-#define SYS_sbrk   12
-#define SYS_sleep  13
+#define SYS_sbrk 12
+#define SYS_sleep 13
 #define SYS_uptime 14
-#define SYS_open   15
-#define SYS_write  16
-#define SYS_mknod  17
+#define SYS_open 15
+#define SYS_write 16
+#define SYS_mknod 17
 #define SYS_unlink 18
-#define SYS_link   19
-#define SYS_mkdir  20
-#define SYS_close  21
+#define SYS_link 19
+#define SYS_mkdir 20
+#define SYS_close 21
+#define SYS_thread_create 22
+#define SYS_thread_join 23
+#define SYS_thread_exit 24
+#define SYS_thread_test 25
+#define SYS_thread_test_spinlock 26
+#define SYS_thread_test_mutex 27
+#define SYS_thread_spinlock_init 28
+#define SYS_thread_spin_lock 29
+#define SYS_thread_spin_unlock 30
diff --git a/sysproc.c b/sysproc.c
index 0686d29..56d3928 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -7,85 +7,141 @@
 #include "mmu.h"
 #include "proc.h"
 
-int
-sys_fork(void)
+int sys_fork(void)
 {
-  return fork();
+    return fork();
 }
 
-int
-sys_exit(void)
+int sys_exit(void)
 {
-  exit();
-  return 0;  // not reached
+    exit();
+    return 0; // not reached
 }
 
-int
-sys_wait(void)
+int sys_wait(void)
 {
-  return wait();
+    return wait();
 }
 
-int
-sys_kill(void)
+int sys_kill(void)
 {
-  int pid;
+    int pid;
 
-  if(argint(0, &pid) < 0)
-    return -1;
-  return kill(pid);
+    if (argint(0, &pid) < 0)
+        return -1;
+    return kill(pid);
 }
 
-int
-sys_getpid(void)
+int sys_getpid(void)
 {
-  return myproc()->pid;
+    return myproc()->pid;
 }
 
-int
-sys_sbrk(void)
+int sys_sbrk(void)
 {
-  int addr;
-  int n;
+    int addr;
+    int n;
 
-  if(argint(0, &n) < 0)
-    return -1;
-  addr = myproc()->sz;
-  if(growproc(n) < 0)
-    return -1;
-  return addr;
+    if (argint(0, &n) < 0)
+        return -1;
+    addr = myproc()->sz;
+    if (growproc(n) < 0)
+        return -1;
+    return addr;
 }
 
-int
-sys_sleep(void)
+int sys_sleep(void)
 {
-  int n;
-  uint ticks0;
+    int n;
+    uint ticks0;
 
-  if(argint(0, &n) < 0)
-    return -1;
-  acquire(&tickslock);
-  ticks0 = ticks;
-  while(ticks - ticks0 < n){
-    if(myproc()->killed){
-      release(&tickslock);
-      return -1;
+    if (argint(0, &n) < 0)
+        return -1;
+    acquire(&tickslock);
+    ticks0 = ticks;
+    while (ticks - ticks0 < n)
+    {
+        if (myproc()->killed)
+        {
+            release(&tickslock);
+            return -1;
+        }
+        sleep(&ticks, &tickslock);
     }
-    sleep(&ticks, &tickslock);
-  }
-  release(&tickslock);
-  return 0;
+    release(&tickslock);
+    return 0;
 }
 
 // return how many clock tick interrupts have occurred
 // since start.
-int
-sys_uptime(void)
+int sys_uptime(void)
 {
-  uint xticks;
+    uint xticks;
 
-  acquire(&tickslock);
-  xticks = ticks;
-  release(&tickslock);
-  return xticks;
+    acquire(&tickslock);
+    xticks = ticks;
+    release(&tickslock);
+    return xticks;
+}
+
+int sys_thread_create(void)
+{
+    void *stack;
+    void *fcn;
+    void *bal;
+
+    argptr(0, (void *)&fcn, sizeof(fcn));
+    argptr(1, (void *)&bal, sizeof(bal));
+    argptr(2, (void *)&stack, sizeof(stack));
+
+    return thread_create(fcn, bal, stack);
+}
+
+int sys_thread_join(void)
+{
+    return thread_join();
+}
+
+int sys_thread_exit(void)
+{
+    return thread_exit();
+}
+
+int sys_thread_test(void)
+{
+    return 0;
+}
+
+int sys_thread_test_spinlock(void)
+{
+    return 0;
+}
+
+void sys_thread_spinlock_init(void)
+{
+    struct spinlock *lk;
+    argptr(0, (void *)&lk, sizeof(lk));
+
+    thread_spinlock_init(lk);
+}
+
+void sys_thread_spin_lock(void)
+{
+    struct spinlock *lk;
+    argptr(0, (void *)&lk, sizeof(lk));
+
+    thread_spin_lock(lk);
+}
+
+void sys_thread_spin_unlock(void)
+{
+    struct spinlock *lk;
+    argptr(0, (void *)&lk, sizeof(lk));
+
+    thread_spin_unlock(lk);
+}
+
+int sys_thread_test_mutex(void)
+{
+    return 0;
 }
diff --git a/thread_test.c b/thread_test.c
new file mode 100644
index 0000000..e157419
--- /dev/null
+++ b/thread_test.c
@@ -0,0 +1,57 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+struct balance
+{
+    char name[32];
+    int amount;
+};
+
+volatile int total_balance = 0;
+volatile unsigned int delay(unsigned int d)
+{
+    unsigned int i;
+    for (i = 0; i < d; i++)
+    {
+        __asm volatile("nop" ::
+                           :);
+    }
+    return i;
+}
+
+void do_work(void *arg)
+{
+    int i;
+    int old;
+    struct balance *b = (struct balance *)arg;
+    printf(1, "Starting do_work: s:%s\n", b->name);
+    for (i = 0; i < b->amount; i++)
+    {
+        // thread_spin_lock(&lock);
+        old = total_balance;
+        delay(100000);
+        total_balance = old + 1;
+        // thread_spin_unlock(&lock);
+    }
+    printf(1, "Done s:%s\n", b->name);
+    thread_exit();
+    return;
+}
+
+int main(int argc, char *argv[])
+{
+    struct balance b1 = {"b1", 3200};
+    struct balance b2 = {"b2", 2800};
+    void *s1, *s2;
+    int t1, t2, r1, r2;
+    s1 = malloc(4096);
+    s2 = malloc(4096);
+    t1 = thread_create(do_work, (void *)&b1, s1);
+    t2 = thread_create(do_work, (void *)&b2, s2);
+    r1 = thread_join();
+    r2 = thread_join();
+    printf(1, "Threads finished: (%d):%d, (%d):%d, shared balance:%d\n",
+           t1, r1, t2, r2, total_balance);
+    exit();
+}
\ No newline at end of file
diff --git a/thread_test_mutex.c b/thread_test_mutex.c
new file mode 100644
index 0000000..2b7029f
--- /dev/null
+++ b/thread_test_mutex.c
@@ -0,0 +1,70 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "mutex.h"
+#include "mutex.c"
+
+struct balance
+{
+    char name[32];
+    int amount;
+};
+
+struct mutexlock lock;
+struct mutexlock lock2;
+
+volatile int total_balance = 0;
+volatile unsigned int delay(unsigned int d)
+{
+    unsigned int i;
+    for (i = 0; i < d; i++)
+    {
+        __asm volatile("nop" ::
+                           :);
+    }
+    return i;
+}
+
+void do_work(void *arg)
+{
+    int i;
+    int old;
+    struct balance *b = (struct balance *)arg;
+
+    thread_mutex_lock(&lock2);
+    printf(1, "Starting do_work: s:%s\n", b->name);
+    thread_mutex_unlock(&lock2);
+
+    for (i = 0; i < b->amount; i++)
+    {
+        thread_mutex_lock(&lock);
+        old = total_balance;
+        delay(100000);
+        total_balance = old + 1;
+        thread_mutex_unlock(&lock);
+    }
+
+    thread_mutex_lock(&lock2);
+    printf(1, "Done s:%s\n", b->name);
+    thread_mutex_unlock(&lock2);
+
+    thread_exit();
+    return;
+}
+
+int main(int argc, char *argv[])
+{
+    struct balance b1 = {"b1", 3200};
+    struct balance b2 = {"b2", 2800};
+    void *s1, *s2;
+    int t1, t2, r1, r2;
+    s1 = malloc(4096);
+    s2 = malloc(4096);
+    t1 = thread_create(do_work, (void *)&b1, s1);
+    t2 = thread_create(do_work, (void *)&b2, s2);
+    r1 = thread_join();
+    r2 = thread_join();
+    printf(1, "Threads finished: (%d):%d, (%d):%d, shared balance:%d\n",
+           t1, r1, t2, r2, total_balance);
+    exit();
+}
\ No newline at end of file
diff --git a/thread_test_spinlock.c b/thread_test_spinlock.c
new file mode 100644
index 0000000..b22da25
--- /dev/null
+++ b/thread_test_spinlock.c
@@ -0,0 +1,72 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "spinlock.h"
+
+struct balance
+{
+    char name[32];
+    int amount;
+};
+
+struct spinlock lock;
+struct spinlock lock2;
+
+volatile int total_balance = 0;
+volatile unsigned int delay(unsigned int d)
+{
+    unsigned int i;
+    for (i = 0; i < d; i++)
+    {
+        __asm volatile("nop" ::
+                           :);
+    }
+    return i;
+}
+
+void do_work(void *arg)
+{
+    int i;
+    int old;
+    struct balance *b = (struct balance *)arg;
+
+    thread_spin_lock(&lock2);
+    printf(1, "Starting do_work: %s\n", b->name);
+    thread_spin_unlock(&lock2);
+
+    for (i = 0; i < b->amount; i++)
+    {
+        thread_spin_lock(&lock);
+        old = total_balance;
+        delay(100000);
+        total_balance = old + 1;
+        thread_spin_unlock(&lock);
+    }
+
+    thread_spin_lock(&lock2);
+    printf(1, "Done: %s\n", b->name);
+    thread_spin_unlock(&lock2);
+
+    thread_exit();
+    return;
+}
+
+int main(int argc, char *argv[])
+{
+    
+    thread_spinlock_init(&lock);
+    thread_spinlock_init(&lock2);
+    struct balance b1 = {"b1", 3200};
+    struct balance b2 = {"b2", 2800};
+    void *s1, *s2;
+    int t1, t2, r1, r2;
+    s1 = malloc(4096);
+    s2 = malloc(4096);
+    t1 = thread_create(do_work, (void *)&b1, s1);
+    t2 = thread_create(do_work, (void *)&b2, s2);
+    r1 = thread_join();
+    r2 = thread_join();
+    printf(1, "Threads finished: (%d):%d, (%d):%d, shared balance:%d\n",
+           t1, r1, t2, r2, total_balance);
+    exit();
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index 4f99c52..c3aad61 100644
--- a/user.h
+++ b/user.h
@@ -5,35 +5,44 @@ struct rtcdate;
 int fork(void);
 int exit(void) __attribute__((noreturn));
 int wait(void);
-int pipe(int*);
-int write(int, const void*, int);
-int read(int, void*, int);
+int pipe(int *);
+int write(int, const void *, int);
+int read(int, void *, int);
 int close(int);
 int kill(int);
-int exec(char*, char**);
-int open(const char*, int);
-int mknod(const char*, short, short);
-int unlink(const char*);
-int fstat(int fd, struct stat*);
-int link(const char*, const char*);
-int mkdir(const char*);
-int chdir(const char*);
+int exec(char *, char **);
+int open(const char *, int);
+int mknod(const char *, short, short);
+int unlink(const char *);
+int fstat(int fd, struct stat *);
+int link(const char *, const char *);
+int mkdir(const char *);
+int chdir(const char *);
 int dup(int);
 int getpid(void);
-char* sbrk(int);
+char *sbrk(int);
 int sleep(int);
 int uptime(void);
+int thread_create(void (*)(void *), void *, void *);
+int thread_join(void);
+int thread_exit(void);
+int thread_test(void);
+int thread_test_spinlock(void);
+int thread_test_mutex(void);
+void thread_spinlock_init(void *);
+void thread_spin_lock(void *);
+void thread_spin_unlock(void *);
 
 // ulib.c
-int stat(const char*, struct stat*);
-char* strcpy(char*, const char*);
-void *memmove(void*, const void*, int);
-char* strchr(const char*, char c);
-int strcmp(const char*, const char*);
-void printf(int, const char*, ...);
-char* gets(char*, int max);
-uint strlen(const char*);
-void* memset(void*, int, uint);
-void* malloc(uint);
-void free(void*);
-int atoi(const char*);
+int stat(const char *, struct stat *);
+char *strcpy(char *, const char *);
+void *memmove(void *, const void *, int);
+char *strchr(const char *, char c);
+int strcmp(const char *, const char *);
+void printf(int, const char *, ...);
+char *gets(char *, int max);
+uint strlen(const char *);
+void *memset(void *, int, uint);
+void *malloc(uint);
+void free(void *);
+int atoi(const char *);
diff --git a/usys.S b/usys.S
index 8bfd8a1..7a4d41e 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,16 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(thread_create)
+SYSCALL(thread_join)
+SYSCALL(thread_exit)
+SYSCALL(thread_test)
+SYSCALL(thread_test_spinlock)
+SYSCALL(thread_test_mutex)
+SYSCALL(thread_spinlock_init)
+SYSCALL(thread_spin_lock)
+SYSCALL(thread_spin_unlock)
+
+
+
+
-- 
2.34.1

